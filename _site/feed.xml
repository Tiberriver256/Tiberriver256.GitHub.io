<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">Tiberriver256</title>
<generator uri="https://github.com/mojombo/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="http://tiberriver256.github.io/feed.xml" />
<link rel="alternate" type="text/html" href="http://tiberriver256.github.io" />
<updated>2016-02-10T06:15:09+00:00</updated>
<id>http://tiberriver256.github.io/</id>
<author>
  <name>Micah Rairdon</name>
  <uri>http://tiberriver256.github.io/</uri>
  <email>Jun(Real Email: Micah.Rairdon [GMail])k@JunkMail.com</email>
</author>


<entry>
  <title type="html"><![CDATA[SAPGUI Scripting with PowerShell]]></title>
 <link rel="alternate" type="text/html" href="http://tiberriver256.github.io/powershell/sap/SAPGUI-Scripting/" />
  <id>http://tiberriver256.github.io/powershell/sap/SAPGUI-Scripting</id>
  <updated>{}T00:00:00-00:00</updated>
  <published>2016-01-25T00:00:00+00:00</published>
  
  <author>
    <name>Micah Rairdon</name>
    <uri>http://tiberriver256.github.io</uri>
    <email>Jun(Real Email: Micah.Rairdon [GMail])k@JunkMail.com</email>
  </author>
  <content type="html">
    &lt;p&gt;Alright, so just wanted to share some brief notes here on a technique for doing SAPGUI scripting from PowerShell.&lt;/p&gt;

&lt;h2 id=&quot;its-not-pretty&quot;&gt;It’s not pretty&lt;/h2&gt;

&lt;p&gt;I’m sure this isn’t the best way to integrate PowerShell and SAP. I’m not an SAP expert but this may help someone in a pinch so I thought I would share.&lt;/p&gt;

&lt;p&gt;By default SAP GUI scripts are recorded in VBScript. The very first thing that is usually done is to call &lt;strong&gt;GetObject(“SAPGUI”)&lt;/strong&gt;. PowerShell can sorta run &lt;strong&gt;GetObject&lt;/strong&gt; but that has &lt;a href=&quot;https://technet.microsoft.com/en-us/library/ee176862.aspx?f=255&amp;amp;MSPPError=-2147217396&quot;&gt;some problems&lt;/a&gt;. None of us want to get into reflection. So what’s the trick? The &lt;strong&gt;MSScriptControl.ScriptControl&lt;/strong&gt; in 32-bit PowerShell.&lt;/p&gt;

&lt;h2 id=&quot;running-sapgui-scripts&quot;&gt;Running SAPGUI scripts&lt;/h2&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;

$ScriptControl = New-Object -comobject MSScriptControl.ScriptControl
$ScriptControl.language = &quot;vbscript&quot;

$Username = &quot;Myusername&quot;
$Password = &quot;MyPassword&quot;

$Login = @&quot;
    If Not IsObject(application) Then
       Set SapGuiAuto  = GetObject(&quot;SAPGUI&quot;)
       Set application = SapGuiAuto.GetScriptingEngine
    End If
    If Not IsObject(connection) Then
       Set connection = application.Children(0)
    End If
    If Not IsObject(session) Then
       Set session    = connection.Children(0)
    End If
    If IsObject(WScript) Then
       WScript.ConnectObject session,     &quot;on&quot;
       WScript.ConnectObject application, &quot;on&quot;
    End If
    session.findById(&quot;wnd[0]&quot;).resizeWorkingPane 140,23,false
    session.findById(&quot;wnd[0]/usr/txtRSYST-BNAME&quot;).text = &quot;$UserName&quot;
    session.findById(&quot;wnd[0]/usr/pwdRSYST-BCODE&quot;).text = &quot;$Password&quot;
    session.findById(&quot;wnd[0]&quot;).sendVKey 0
&quot;@

$ScriptControl.AddCode($Login)

&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;*Note the username and password are passed into the script using a here-string before the script is added to the script object.&lt;/p&gt;

&lt;h2 id=&quot;returning-text-from-sapgui-to-powershell&quot;&gt;Returning text from SAPGUI to PowerShell&lt;/h2&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;

$UserNameFromSAP = $ScriptControl.Eval(&#39;session.findById(&quot;wnd[0]/usr/txtRSYST-BNAME&quot;).text&#39;)

&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;I have used AddCode to script / automate the GUI up to the point where I would need to pull data to SAP then at that point I would extract the data using the &lt;strong&gt;Eval&lt;/strong&gt; method, run the PowerShell code, then feed it back in using a here-string built vbscript using the result of the PowerShell script.&lt;/p&gt;

&lt;p&gt;Kind of clunky but it works. The scripting object is actually really cool. It can return entire objects from vbscriptland to PowerShell. You can almost fully bring it out of vbscript into PowerShell with this oneliner&lt;/p&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;

$SAPGUI = $ScriptControl.Eval(&#39;(GetObject(&quot;SAPGUI&quot;)).GetScriptingEngine.Children(0).Children(0)&#39;)

&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;Using this little chunk of code exposes the majorit of methods you would need to automate SAPGUI (i.e. &lt;strong&gt;$SAPGUI.FindByID(“wnd[0]/usr/txtRSYST-BNAME”).text&lt;/strong&gt; would actually return the text value of that field, but I ran into areas where I would be needing to use reflection for certain methods so I dropped it.&lt;/p&gt;

&lt;p&gt;The real problem though is that particular COM object is only available in 32-bit PowerShell which means you have to either script for 32-bit or run &lt;strong&gt;Start-Job -RunAs32 -ScriptBlock { [Code here] }&lt;/strong&gt; which isn’t the funnest way to code.&lt;/p&gt;

&lt;p&gt;There ya have it though, I hope someone finds it useful. Like I said at the beginning of this post, there are better solutions out there for this. I know the community at AutoIT have made some nice tooling around SAPGUI scripting. It would be nice if we could bring more of it into PowerShell somehow.&lt;/p&gt;

&lt;p&gt;P.S. If you’re looking for a better script recorder than the SAPGUI built-in tooling &lt;a href=&quot;http://tracker.stschnell.de/&quot;&gt;http://tracker.stschnell.de/&lt;/a&gt; is the best I’ve found.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/sap/SAPGUI-Scripting/&quot;&gt;SAPGUI Scripting with PowerShell&lt;/a&gt; was originally published by Micah Rairdon at &lt;a href=&quot;http://tiberriver256.github.io&quot;&gt;Tiberriver256&lt;/a&gt; on January 25, 2016.&lt;/p&gt;
  </content>
</entry>


<entry>
  <title type="html"><![CDATA[What's in a cmdlet?]]></title>
 <link rel="alternate" type="text/html" href="http://tiberriver256.github.io/powershell/utility/qa%20testing/WhatsInACmdlet/" />
  <id>http://tiberriver256.github.io/powershell/utility/qa%20testing/WhatsInACmdlet</id>
  <updated>{}T00:00:00-00:00</updated>
  <published>2016-01-23T00:00:00+00:00</published>
  
  <author>
    <name>Micah Rairdon</name>
    <uri>http://tiberriver256.github.io</uri>
    <email>Jun(Real Email: Micah.Rairdon [GMail])k@JunkMail.com</email>
  </author>
  <content type="html">
    &lt;p&gt;Have you ever used the magical cmdlet called &lt;strong&gt;Show-Command&lt;/strong&gt;? Ever wonder how it knows what type of GUI form object to assign to each particular parameter in your cmdlet? Did you even know it works with any cmdlet?&lt;/p&gt;

&lt;p&gt;It is a pretty magical cmdlet. One with which you should play sometime. Today, I am going to show you briefly how to see the same data that is used to generate those GUIs. All you would need to do is determine the specific type (i.e. string, integer, boolean) and map that to a specific form object. for example if a parameter expected a string input you would map that to a simple text input. If it expected a boolean you would map it to a checkbox. Cool, but how would I store that information for my custom cmdlets and how would I access that information? The answers are not as bad as you would think.&lt;/p&gt;

&lt;p&gt;Storing the info = Params
Getting the info = &lt;strong&gt;Get-Command&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;params&quot;&gt;Params&lt;/h2&gt;

&lt;p&gt;All the information regarding what information you expect to be given to your cmdlet is defined in your params. See &lt;a href=&quot;https://technet.microsoft.com/en-us/magazine/jj554301.aspx,&quot; title=&quot;Windows PowerShell: Defining Parameters&quot;&gt;this article&lt;/a&gt; for a simple walkthrough on params. It’s an oldie but a goodie.&lt;/p&gt;

&lt;h2 id=&quot;get-command&quot;&gt;Get-Command&lt;/h2&gt;

&lt;p&gt;Anyone who has watched a PowerShell tutorial knows &lt;strong&gt;Get-Command&lt;/strong&gt;. It’s one of the first things they tell you. Not sure what you are looking for? Get command takes wildcards! Use it to search for the command you are looking for like this:&lt;/p&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;

Get-Command *SQL*

&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;It should return any cmdlets that have the keyword “SQL” in them! COOL! WOW! AWESOME! We then leave the cmdlet and go on to other awesome things. Meanwhile… &lt;strong&gt;Get-Command&lt;/strong&gt; is saying… &lt;em&gt;Wait! I can do SO much more for you!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Check out how much info I can get on a simple command like &lt;strong&gt;Read-Host&lt;/strong&gt;. You can see the &lt;strong&gt;Parameters&lt;/strong&gt; property should fulfill our needs.&lt;/p&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;

(Get-Command Read-Host).Parameters | ConvertTo-Json -Depth 1

&lt;/code&gt; &lt;/pre&gt;

&lt;h2 id=&quot;alllll-the-info&quot;&gt;ALLLLL the info!&lt;/h2&gt;

&lt;pre&gt;
&lt;code class=&quot;json&quot;&gt;

{
    &quot;Prompt&quot;:  {
                   &quot;Name&quot;:  &quot;Prompt&quot;,
                   &quot;ParameterType&quot;:  &quot;System.Object&quot;,
                   &quot;ParameterSets&quot;:  &quot;System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterSetMetadata]&quot;,
                   &quot;IsDynamic&quot;:  false,
                   &quot;Aliases&quot;:  &quot;&quot;,
                   &quot;Attributes&quot;:  &quot;System.Management.Automation.AllowNullAttribute System.Management.Automation.ParameterAttribute&quot;,
                   &quot;SwitchParameter&quot;:  false
               },
    &quot;AsSecureString&quot;:  {
                           &quot;Name&quot;:  &quot;AsSecureString&quot;,
                           &quot;ParameterType&quot;:  &quot;switch&quot;,
                           &quot;ParameterSets&quot;:  &quot;System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterSetMetadata]&quot;,
                           &quot;IsDynamic&quot;:  false,
                           &quot;Aliases&quot;:  &quot;&quot;,
                           &quot;Attributes&quot;:  &quot;System.Management.Automation.ParameterAttribute&quot;,
                           &quot;SwitchParameter&quot;:  true
                       },
    &quot;Verbose&quot;:  {
                    &quot;Name&quot;:  &quot;Verbose&quot;,
                    &quot;ParameterType&quot;:  &quot;switch&quot;,
                    &quot;ParameterSets&quot;:  &quot;System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterSetMetadata]&quot;,
                    &quot;IsDynamic&quot;:  false,
                    &quot;Aliases&quot;:  &quot;vb&quot;,
                    &quot;Attributes&quot;:  &quot;System.Management.Automation.AliasAttribute System.Management.Automation.ParameterAttribute&quot;,
                    &quot;SwitchParameter&quot;:  true
                },
    &quot;Debug&quot;:  {
                  &quot;Name&quot;:  &quot;Debug&quot;,
                  &quot;ParameterType&quot;:  &quot;switch&quot;,
                  &quot;ParameterSets&quot;:  &quot;System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterSetMetadata]&quot;,
                  &quot;IsDynamic&quot;:  false,
                  &quot;Aliases&quot;:  &quot;db&quot;,
                  &quot;Attributes&quot;:  &quot;System.Management.Automation.AliasAttribute System.Management.Automation.ParameterAttribute&quot;,
                  &quot;SwitchParameter&quot;:  true
              },
    &quot;ErrorAction&quot;:  {
                        &quot;Name&quot;:  &quot;ErrorAction&quot;,
                        &quot;ParameterType&quot;:  &quot;System.Management.Automation.ActionPreference&quot;,
                        &quot;ParameterSets&quot;:  &quot;System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterSetMetadata]&quot;,
                        &quot;IsDynamic&quot;:  false,
                        &quot;Aliases&quot;:  &quot;ea&quot;,
                        &quot;Attributes&quot;:  &quot;System.Management.Automation.ParameterAttribute System.Management.Automation.AliasAttribute&quot;,
                        &quot;SwitchParameter&quot;:  false
                    },
    &quot;WarningAction&quot;:  {
                          &quot;Name&quot;:  &quot;WarningAction&quot;,
                          &quot;ParameterType&quot;:  &quot;System.Management.Automation.ActionPreference&quot;,
                          &quot;ParameterSets&quot;:  &quot;System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterSetMetadata]&quot;,
                          &quot;IsDynamic&quot;:  false,
                          &quot;Aliases&quot;:  &quot;wa&quot;,
                          &quot;Attributes&quot;:  &quot;System.Management.Automation.ParameterAttribute System.Management.Automation.AliasAttribute&quot;,
                          &quot;SwitchParameter&quot;:  false
                      },
    &quot;InformationAction&quot;:  {
                              &quot;Name&quot;:  &quot;InformationAction&quot;,
                              &quot;ParameterType&quot;:  &quot;System.Management.Automation.ActionPreference&quot;,
                              &quot;ParameterSets&quot;:  &quot;System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterSetMetadata]&quot;,
                              &quot;IsDynamic&quot;:  false,
                              &quot;Aliases&quot;:  &quot;infa&quot;,
                              &quot;Attributes&quot;:  &quot;System.Management.Automation.ParameterAttribute System.Management.Automation.AliasAttribute&quot;,
                              &quot;SwitchParameter&quot;:  false
                          },
    &quot;ErrorVariable&quot;:  {
                          &quot;Name&quot;:  &quot;ErrorVariable&quot;,
                          &quot;ParameterType&quot;:  &quot;string&quot;,
                          &quot;ParameterSets&quot;:  &quot;System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterSetMetadata]&quot;,
                          &quot;IsDynamic&quot;:  false,
                          &quot;Aliases&quot;:  &quot;ev&quot;,
                          &quot;Attributes&quot;:  &quot;System.Management.Automation.AliasAttribute System.Management.Automation.ParameterAttribute System.Management.Automation.Internal.CommonParameters+ValidateVariableName&quot;,
                          &quot;SwitchParameter&quot;:  false
                      },
    &quot;WarningVariable&quot;:  {
                            &quot;Name&quot;:  &quot;WarningVariable&quot;,
                            &quot;ParameterType&quot;:  &quot;string&quot;,
                            &quot;ParameterSets&quot;:  &quot;System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterSetMetadata]&quot;,
                            &quot;IsDynamic&quot;:  false,
                            &quot;Aliases&quot;:  &quot;wv&quot;,
                            &quot;Attributes&quot;:  &quot;System.Management.Automation.Internal.CommonParameters+ValidateVariableName System.Management.Automation.ParameterAttribute System.Management.Automation.AliasAttribute&quot;,
                            &quot;SwitchParameter&quot;:  false
                        },
    &quot;InformationVariable&quot;:  {
                                &quot;Name&quot;:  &quot;InformationVariable&quot;,
                                &quot;ParameterType&quot;:  &quot;string&quot;,
                                &quot;ParameterSets&quot;:  &quot;System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterSetMetadata]&quot;,
                                &quot;IsDynamic&quot;:  false,
                                &quot;Aliases&quot;:  &quot;iv&quot;,
                                &quot;Attributes&quot;:  &quot;System.Management.Automation.Internal.CommonParameters+ValidateVariableName System.Management.Automation.ParameterAttribute System.Management.Automation.AliasAttribute&quot;,
                                &quot;SwitchParameter&quot;:  false
                            },
    &quot;OutVariable&quot;:  {
                        &quot;Name&quot;:  &quot;OutVariable&quot;,
                        &quot;ParameterType&quot;:  &quot;string&quot;,
                        &quot;ParameterSets&quot;:  &quot;System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterSetMetadata]&quot;,
                        &quot;IsDynamic&quot;:  false,
                        &quot;Aliases&quot;:  &quot;ov&quot;,
                        &quot;Attributes&quot;:  &quot;System.Management.Automation.Internal.CommonParameters+ValidateVariableName System.Management.Automation.ParameterAttribute System.Management.Automation.AliasAttribute&quot;,
                        &quot;SwitchParameter&quot;:  false
                    },
    &quot;OutBuffer&quot;:  {
                      &quot;Name&quot;:  &quot;OutBuffer&quot;,
                      &quot;ParameterType&quot;:  &quot;int&quot;,
                      &quot;ParameterSets&quot;:  &quot;System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterSetMetadata]&quot;,
                      &quot;IsDynamic&quot;:  false,
                      &quot;Aliases&quot;:  &quot;ob&quot;,
                      &quot;Attributes&quot;:  &quot;System.Management.Automation.ParameterAttribute System.Management.Automation.AliasAttribute System.Management.Automation.ValidateRangeAttribute&quot;,
                      &quot;SwitchParameter&quot;:  false
                  },
    &quot;PipelineVariable&quot;:  {
                             &quot;Name&quot;:  &quot;PipelineVariable&quot;,
                             &quot;ParameterType&quot;:  &quot;string&quot;,
                             &quot;ParameterSets&quot;:  &quot;System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterSetMetadata]&quot;,
                             &quot;IsDynamic&quot;:  false,
                             &quot;Aliases&quot;:  &quot;pv&quot;,
                             &quot;Attributes&quot;:  &quot;System.Management.Automation.Internal.CommonParameters+ValidateVariableName System.Management.Automation.ParameterAttribute System.Management.Automation.AliasAttribute&quot;,
                             &quot;SwitchParameter&quot;:  false
                         }
}



&lt;/code&gt; &lt;/pre&gt;

    &lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/utility/qa%20testing/WhatsInACmdlet/&quot;&gt;What&#39;s in a cmdlet?&lt;/a&gt; was originally published by Micah Rairdon at &lt;a href=&quot;http://tiberriver256.github.io&quot;&gt;Tiberriver256&lt;/a&gt; on January 23, 2016.&lt;/p&gt;
  </content>
</entry>


<entry>
  <title type="html"><![CDATA[Command Combinations]]></title>
 <link rel="alternate" type="text/html" href="http://tiberriver256.github.io/powershell/utility/qa%20testing/CommandCombinations/" />
  <id>http://tiberriver256.github.io/powershell/utility/qa%20testing/CommandCombinations</id>
  <updated>{}T00:00:00-00:00</updated>
  <published>2016-01-20T00:00:00+00:00</published>
  
  <author>
    <name>Micah Rairdon</name>
    <uri>http://tiberriver256.github.io</uri>
    <email>Jun(Real Email: Micah.Rairdon [GMail])k@JunkMail.com</email>
  </author>
  <content type="html">
    &lt;p&gt;So I had an idea the other day. Wouldn’t it be cool if I could run EVERY single possible command combinations for my &lt;a href=&quot;https://tiberriver256.github.io/PoshProgressBar&quot;&gt;PoshProgressBar Module&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;That would be awesome! Wny would that be so awesome?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Automated testing&lt;/strong&gt; – To guarantee that every single progress bar combination actually ran as expected&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Screenshots&lt;/strong&gt; – The website has a cool dynamic command builder form to fill out that will generate your PowerShell command. It would be sweet to hit “Preview” and see a screenshot of exactly what that particular progress bar looks like.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So… doesn’t sound too bad right? All of the parameters you can use in the module have parameter sets so the possible inputs are definitely limited.&lt;/p&gt;

&lt;p&gt;I also know you can get to all that metadata using &lt;strong&gt;Get-Command&lt;/strong&gt; &lt;em&gt;Stay tuned for a later blog post&lt;/em&gt;. But would I be able to get all the combinations?&lt;/p&gt;

&lt;p&gt;Let’s start doing the math… wait… math is hard… let’s keep it simple.&lt;/p&gt;

&lt;p&gt;I have two arrays of three words each:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Cat’s are scary&lt;/li&gt;
  &lt;li&gt;Dog’s are cool&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I have three possible combinations of the first word “Cat’s” and each of the three words in the second array. Then I have three words in the first array so I can put it simply as 3 x 3 = 9 combinations.&lt;/p&gt;

&lt;p&gt;If I add to that a third array of three words we get 3&lt;sup&gt;3&lt;/sup&gt; or 27 possibilities. Yikes this could get complicated to build especially with the amount of values I have in each of my parameter sets.&lt;/p&gt;

&lt;p&gt;I did however get a basic function together that would generate all possible combinations. It does not take into consideration parameter sets or required parameters yet though.&lt;/p&gt;

&lt;p&gt;Now I just have to find the time to run through all 97920 possible command lines for my &lt;strong&gt;New-ProgressBar&lt;/strong&gt; cmdlet with an &lt;strong&gt;Invoke-Expression&lt;/strong&gt; calling them followed by a cmdlet to grab them with a screenshot.&lt;/p&gt;

&lt;p&gt;One screenshot a second though… this is going to take awhile…&lt;/p&gt;

&lt;h2 id=&quot;check-out-the-code&quot;&gt;Check out the code&lt;/h2&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;

function Get-StringCombinations
{

    Param(
        $MultiArray
    )
    
    function Recursive-Combine($MultiArray, $Count, $String)
    {

        foreach ($SubString in $MultiArray[$Count])
        {

             if( $Count -lt ( $MultiArray.count - 1 ) )
             {

                
                Recursive-Combine -MultiArray $MultiArray -Count ( $Count + 1 ) -String &quot;$String $SubString&quot;

             }
             else
             {

                &quot;$String $SubString&quot;

             }

        }

    }

    foreach ($String in $MultiArray[0]) {
            
            Recursive-Combine -MultiArray $MultiArray -Count ($Count+1) -String $String

    }

}

$CommonParamaters = @(
    &quot;Verbose&quot;, &quot;Debug&quot;, 
    &quot;ErrorAction&quot;, &quot;WarningAction&quot;, 
    &quot;InformationAction&quot;, &quot;ErrorVariable&quot;, 
    &quot;WarningVariable&quot;, &quot;InformationVariable&quot;, 
    &quot;OutVariable&quot;, &quot;OutBuffer&quot;, 
    &quot;PipelineVariable&quot;
    )

function Get-AllParameters ($Command)
{

    $Command = Get-Command $Command

    $Parameters = $Command.Parameters.Keys.ForEach({$Command.Parameters[$_]}) | where {$CommonParamaters -notcontains $_.Name}

    $ValidateSetParameters = $Parameters | where { 
    
        ( $_.Attributes | foreach { $_.TypeId.FullName } ) -contains &quot;System.Management.Automation.ValidateSetAttribute&quot; 
        
    }
    
    $AllParameters = @()

    foreach($Parameter in $ValidateSetParameters) { 
        
        $Array = @()

        ($Parameter.Attributes | where { 
        
                            $_.TypeId.FullName -eq &quot;System.Management.Automation.ValidateSetAttribute&quot; 
                        
                        } ).validValues | foreach { $Array += ( &quot;-$($Parameter.Name) $_&quot;) } 

        $Array += (&quot;&quot;)

        $AllParameters += @(,$Array)
        
    }

    $OtherParameters = $Parameters | where { $ValidateSetParameters -notcontains $_ }


    $PossibleValues = @{

        &quot;System.String&quot;=&quot;TestString&quot;
        &quot;System.String[]&quot;=@(&quot;TestString1&quot;,&quot;TestString2&quot;)
        &quot;System.Boolean&quot;=@(&#39;$True&#39;,&#39;$False&#39;)

    }

    foreach ($Parameter in $OtherParameters) {
        
        $Array = @()

        if($Parameter.ParameterType.FullName -eq &quot;System.Management.Automation.SwitchParameter&quot;)
        {

            $Array += (&quot;-$($Parameter.Name)&quot;)

        } else {

            $PossibleValues[&quot;$($Parameter.ParameterType.FullName)&quot;] | foreach {
        
                $Array += (&quot;-$($Parameter.Name) $_&quot;)
        
            }

        }

        $Array += (&quot;&quot;)

        $AllParameters += @(,$Array)

    }

    return $AllParameters

}

$AllParameters = Get-AllParameters -Command &quot;New-ProgressBar&quot;
$AllPossibleCommandlines = Get-StringCombinations $AllParameters

&lt;/code&gt; &lt;/pre&gt;

    &lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/utility/qa%20testing/CommandCombinations/&quot;&gt;Command Combinations&lt;/a&gt; was originally published by Micah Rairdon at &lt;a href=&quot;http://tiberriver256.github.io&quot;&gt;Tiberriver256&lt;/a&gt; on January 20, 2016.&lt;/p&gt;
  </content>
</entry>


<entry>
  <title type="html"><![CDATA[PowerShell ProgressBar -- The Module]]></title>
 <link rel="alternate" type="text/html" href="http://tiberriver256.github.io/powershell/PowerShellProgress-TheModule/" />
  <id>http://tiberriver256.github.io/powershell/PowerShellProgress-TheModule</id>
  <updated>{}T00:00:00-00:00</updated>
  <published>2016-01-04T00:00:00+00:00</published>
  
  <author>
    <name>Micah Rairdon</name>
    <uri>http://tiberriver256.github.io</uri>
    <email>Jun(Real Email: Micah.Rairdon [GMail])k@JunkMail.com</email>
  </author>
  <content type="html">
    &lt;h2 id=&quot;the-series&quot;&gt;The Series&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt1/&quot;&gt;PowerShell ProgressBar – Part 1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt2/&quot;&gt;PowerShell ProgressBar – Part 2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt3/&quot;&gt;PowerShell ProgressBar – Part 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt4/&quot;&gt;PowerShell ProgressBar – Part 4&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Hey everyone!&lt;/p&gt;

&lt;p&gt;Just wanted to say thank you for all the wonderful feedback I have received on the previous four articles by putting them into a module that hopefully makes the code easier to use.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/PoshProgressBar&quot; title=&quot;The Module&quot;&gt;Check out the full details&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-TheModule/&quot;&gt;PowerShell ProgressBar -- The Module&lt;/a&gt; was originally published by Micah Rairdon at &lt;a href=&quot;http://tiberriver256.github.io&quot;&gt;Tiberriver256&lt;/a&gt; on January 04, 2016.&lt;/p&gt;
  </content>
</entry>


<entry>
  <title type="html"><![CDATA[PowerShell ProgressBar -- Part 4]]></title>
 <link rel="alternate" type="text/html" href="http://tiberriver256.github.io/powershell/PowerShellProgress-Pt4/" />
  <id>http://tiberriver256.github.io/powershell/PowerShellProgress-Pt4</id>
  <updated>{}T00:00:00-00:00</updated>
  <published>2015-12-18T00:00:00+00:00</published>
  
  <author>
    <name>Micah Rairdon</name>
    <uri>http://tiberriver256.github.io</uri>
    <email>Jun(Real Email: Micah.Rairdon [GMail])k@JunkMail.com</email>
  </author>
  <content type="html">
    &lt;h2 id=&quot;the-series&quot;&gt;The Series&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt1/&quot;&gt;PowerShell ProgressBar – Part 1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt2/&quot;&gt;PowerShell ProgressBar – Part 2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt3/&quot;&gt;PowerShell ProgressBar – Part 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-TheModule/&quot;&gt;The Module Released&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Alright, so we have the details lined out that we want to see. We have decent performance so we know our progress bar is not going to crash anyones system or slow our awesome sauce PowerShell scripts down. Now what?&lt;/p&gt;

&lt;p&gt;It looks decent, how about let’s make it look good and add a few color options? Seems like a complicated task right? Enter… XAML templates.&lt;/p&gt;

&lt;h2 id=&quot;xaml-templates&quot;&gt;XAML Templates&lt;/h2&gt;

&lt;p&gt;So, one of the reason I love hacking stuff together in HTML is that you can Google for 5 seconds and find a million awesome looking css frameworks that you can &amp;lt;LINK href=&amp;gt; into your page and it makes you look like you are good with colors or something like that.&lt;/p&gt;

&lt;p&gt;The same thing exists (although not quite as prevalent) in XAML.You can spec out designs for a XAML textbox, save that as a separate xaml, reference it at the beginning of your XAML and it automagically makes copies in the styling that you defined previously &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/cc189093(VS.95).aspx&quot; title=&quot;Customizing the Appearance of an Existing Control by Using a ControlTemplate&quot;&gt;(MSDN Walkthrough)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Does this mean I made my own XAML templates? Heck no. There are free ones out there that are way better than anything I could ever come up with.&lt;/p&gt;

&lt;p&gt;If you have not heard of Material Design yet, it is a design spec published by Google you can read about here&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. Basically Google sharing with us lower peeps what good looks like. Let’s take a look and see what it takes to apply ButchersBoy’s Material Design in XAML Toolkit&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; to our progressbar.&lt;/p&gt;

&lt;h2 id=&quot;adding-in-the-magic&quot;&gt;Adding in the magic&lt;/h2&gt;

&lt;h3 id=&quot;step-1----import-dlls&quot;&gt;Step 1 – Import DLLs&lt;/h3&gt;

&lt;p&gt;You can download the compiled DLLs for his project from the github source page &lt;a href=&quot;https://github.com/ButchersBoy/MaterialDesignInXamlToolkit/releases/download/v1.1.0/MaterialDesignThemes1_1_net40.zip&quot; title=&quot;.NET 4.0 compatible&quot;&gt;here (1.68 MB)&lt;/a&gt;. The latest build he has posted there requires .NET 4.5. It does some cool stuff but we don’t need super duper fancy for our progress bars, so I went with backwards compatibility.&lt;/p&gt;

&lt;p&gt;Unzip the DLLs into the folder of your choice and then import them using the &lt;strong&gt;Import-Module&lt;/strong&gt; cmdlet as follows (Make sure to unblock them first):&lt;/p&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;
Import-Module .\src\MaterialDesignColors.dll -ErrorAction Stop
Import-Module .\src\MaterialDesignThemes.Wpf.dll -ErrorAction Stop
&lt;/code&gt; &lt;/pre&gt;

&lt;h3 id=&quot;step-2---referencing-the-resource-dictionaries&quot;&gt;Step 2 - Referencing the Resource Dictionaries&lt;/h3&gt;

&lt;p&gt;Now, per ButchersBoy’s getting started guide&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;, we need to add the proper resource dictionaries to our prior XAML code. Resource dictionaries, in case you haven’t read the MSDN article above (&lt;em&gt;and you should&lt;/em&gt;), are similar to css libraries in my mind. They hold the magic styling sauce for your XAML GUI.&lt;/p&gt;

&lt;p&gt;Since my top level element is Window, I want to add the resource dictionaries into the following XML block:&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;xml&quot;&gt;
                    &lt;window.resources&gt;
                        &lt;resourcedictionary&gt;
                            &lt;resourcedictionary.mergeddictionaries&gt;
                            
                            #####
                            [Insert dictionary references here]
                            #####
                            
                            &lt;/resourcedictionary.mergeddictionaries&gt;            
                        &lt;/resourcedictionary&gt;
                    &lt;/window.resources&gt;
&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;He has a lot of dictionaries for us to choose from. We can choose either a dark or light theme by using the following line. I picked the Dark theme:&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;xml&quot;&gt;
&lt;resourcedictionary source=&quot;pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Dark.xaml&quot; /&gt;
&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;Then we add the default xaml file in:&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;xml&quot;&gt;
&lt;resourcedictionary source=&quot;pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Defaults.xaml&quot; /&gt;
&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;Then we pick our primary and accent colors. I picked blue for my primary and lightblue for my accent. You can see the full list of colors &lt;a href=&quot;https://github.com/ButchersBoy/MaterialDesignInXamlToolkit/tree/master/MaterialDesignColors.Wpf/Themes/Recommended&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;xml&quot;&gt;
&lt;resourcedictionary source=&quot;pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Primary/MaterialDesignColor.Blue.xaml&quot; /&gt;
&lt;resourcedictionary source=&quot;pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Accent/MaterialDesignColor.LightBlue.xaml&quot; /&gt;
&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;Lastly we add in some extra properties to the Window element as follows:&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;xml&quot;&gt;
&amp;lt;Window [...]
        TextElement.Foreground=&quot;{DynamicResource MaterialDesignBody}&quot;
        Background=&quot;{DynamicResource MaterialDesignPaper}&quot;
        TextElement.FontWeight=&quot;Medium&quot;
        TextElement.FontSize=&quot;14&quot;
        FontFamily=&quot;pack://application:,,,/MaterialDesignThemes.Wpf;component/Resources/Roboto/#Roboto&quot;
        [...] &amp;gt;
&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;That’s it! Now re-run the script from last week and it will look like this:&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;http://tiberriver256.github.io/images/PowerProgress/PowerShell ProgressBar - Material Design 1.gif&quot; /&gt;
	&lt;figcaption&gt;Behold Material Design in PowerShell&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Sweet! Now… what about one of those fancy circle progress bars? Wouldn’t that be cool? Well… turns out… now that we have our framework in place all we have to change is our progress bar XAML line to look like this:&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;xml&quot;&gt;
&lt;progressbar style=&quot;{StaticResource MaterialDesignCircularProgressBar}&quot; height=&quot;560&quot; width=&quot;560&quot; name=&quot;ProgressBar&quot; /&gt;
&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;Adjust the width on your window to be 630 to fit the width of the circular progressbar and voila!&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;http://tiberriver256.github.io/images/PowerProgress/PowerShell ProgressBar - Material Design 2.gif&quot; /&gt;
	&lt;figcaption&gt;Behold Material Design Circlular Progress Bars in PowerShell&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;That wasn’t so bad right? Now, it’s still way too much work to edit and discover all that’s out there so with anything let’s build it into our function.&lt;/p&gt;

&lt;h3 id=&quot;step-3---building-dynamic-xaml-with-powershell-herestrings&quot;&gt;Step 3 - Building dynamic XAML with PowerShell herestrings&lt;/h3&gt;

&lt;p&gt;There are three different methods we could use for building out the necessary XAML to cover all possible variations of the xaml we have just looked at:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We could statically type out all of the possibilities, save them as individual XAML and then import them using something like the following:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;
$xaml = Get-Content &quot;.\src\$Theme_$Color_$ProgressBarStyle_$SizeVariation.xaml&quot;
&lt;/code&gt; &lt;/pre&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;We could use the build the string as you go method with something like the following:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;
$xaml = @&quot;
&lt;window xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; name=&quot;Window&quot; title=&quot;Progress...&quot; windowstartuplocation=&quot;CenterScreen&quot; width=&quot;630&quot; height=&quot;130&quot; sizetocontent=&quot;Height&quot; showintaskbar=&quot;True&quot; textelement.foreground=&quot;{DynamicResource MaterialDesignBody}&quot; background=&quot;{DynamicResource MaterialDesignPaper}&quot; textelement.fontweight=&quot;Medium&quot; textelement.fontsize=&quot;14&quot; fontfamily=&quot;pack://application:,,,/MaterialDesignThemes.Wpf;component/Resources/Roboto/#Roboto&quot;&gt; 
            
            &lt;window.resources&gt;
                &lt;resourcedictionary&gt;
                    &lt;resourcedictionary.mergeddictionaries&gt;
&quot;@

if($Theme -eq &quot;Dark&quot;)
{
    $xaml += &#39;&lt;resourcedictionary source=&quot;pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Dark.xaml&quot; /&gt;&#39;
}
 

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;We could use dynamically created here-strings.&lt;/li&gt;
&lt;/ol&gt;

How do we dynamically create a &quot;here-string&quot;? There are two types of here-strings ([Read up on them here](https://technet.microsoft.com/en-us/library/ee692792.aspx &quot;Windows PowerShell Tip: Using Windows PowerShell Here-Strings&quot;)).

 1. Those that start with @&quot; and end with &quot;@
 2. Those that start with @&#39; and end with &#39;@

The first type will expand any variables inside the here-string ([More on Variable Expansion in Strings](http://blogs.msdn.com/b/powershell/archive/2006/07/15/variable-expansion-in-strings-and-herestrings.aspx &quot;Variable Expansion in Strings&quot;)). The second will not. This means if we put an expression inside the here-string it will execute the expression and return the results directly into the string you are creating. So if I wanted to only add special properties to the window XAML element if someone uses a **-MaterialDesign** switch I could type a here-string like the following:

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;
$syncHash.XAML = @&quot; 
        &amp;lt;Window 
            xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; 
            xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; 
            Name=&quot;Window&quot; Title=&quot;Progress...&quot; WindowStartupLocation = &quot;CenterScreen&quot; 
            Width = &quot;560&quot;
            $(
                if($MaterialDesign)
                {
                    @&#39;
                        TextElement.Foreground=&quot;{DynamicResource MaterialDesignBody}&quot;
                        Background=&quot;{DynamicResource MaterialDesignPaper}&quot;
                        TextElement.FontWeight=&quot;Medium&quot;
                        TextElement.FontSize=&quot;14&quot;
                        FontFamily=&quot;pack://application:,,,/MaterialDesignThemes.Wpf;component/Resources/Roboto/#Roboto&quot;
    &#39;@
                }
            )
            &amp;gt;
&quot;@
&lt;/code&gt; &lt;/pre&gt;

The middle string only gets added if the switch is present. This does make the code a bit more difficult to read but, for me at least, speeds up the development process and is a little bit of a personal preference.

I was able to code out a full function **New-ProgressBar** in a pretty short time that gives all the possible options and I think it is decently maintainable as long as you know how here-strings work.

Check it out!

&lt;figure&gt;
	&lt;img src=&quot;http://tiberriver256.github.io/images/PowerProgress/PowerShell ProgressBar - Material Design 3.gif&quot; /&gt;
	&lt;figcaption&gt;Behold Material Design Circlular Progress Bars in PowerShell&lt;/figcaption&gt;
&lt;/figure&gt;

The full code is getting pretty long to post right here so I threw it up on GitHub to [download](https://github.com/Tiberriver256/PoshProgressBar &quot;PoshProgressBar&quot;). 


## Demo

Don&#39;t forget to change the file path of the **Import-Module** function in the **New-ProgressBar** function to match the location of your [downloaded DLLs (Reference Step 1 of this blog posting)](https://github.com/ButchersBoy/MaterialDesignInXamlToolkit/releases/download/v1.1.0/MaterialDesignThemes1_1_net40.zip &quot;.NET 4.0 compatible&quot;) otherwise it will default to using the basic styling.

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;
$Files = dir $env:USERPROFILE -Recurse


$ProgressBars = @()

$ProgressBars += New-ProgressBar -MaterialDesign -IsIndeterminate $true -Type Circle -PrimaryColor Green -AccentColor DeepPurple -Size Large -Theme Dark
$ProgressBars += New-ProgressBar -MaterialDesign -Type Horizontal -PrimaryColor Red -AccentColor LightBlue -Size Medium -Theme Light
$ProgressBars += New-ProgressBar -MaterialDesign -Type Vertical -PrimaryColor Amber -AccentColor DeepOrange -Size Large -Theme Dark
$ProgressBars += New-ProgressBar -MaterialDesign -Type Circle -PrimaryColor Blue -AccentColor Cyan -Size Small -Theme Light

Start-Sleep -Seconds 2

$i = 0
foreach ($File in $Files) { 
                    $i++
                    Start-Sleep -Milliseconds 2
                    foreach ($ProgressBar in $ProgressBars) {
    
    
                        Write-ProgressBar `
                                -ProgressBar $ProgressBar `
                                -Activity &quot;Viewing Files&quot; `
                                -PercentComplete (($i/$Files.count) * 100) `
                                -CurrentOperation $File.FullName `
                                -Status $File.Name `
                                -SecondsRemaining ($Files.Count - $i)

                    }

                }
&lt;/code&gt; &lt;/pre&gt;

 
&lt;/resourcedictionary.mergeddictionaries&gt;&lt;/resourcedictionary&gt;&lt;/window.resources&gt;&lt;/window&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;https://www.google.com/design/spec/material-design/introduction.html &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;http://materialdesigninxaml.net/ &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;https://github.com/ButchersBoy/MaterialDesignInXamlToolkit/wiki/Getting-Started &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;

    &lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt4/&quot;&gt;PowerShell ProgressBar -- Part 4&lt;/a&gt; was originally published by Micah Rairdon at &lt;a href=&quot;http://tiberriver256.github.io&quot;&gt;Tiberriver256&lt;/a&gt; on December 18, 2015.&lt;/p&gt;
  </content>
</entry>


<entry>
  <title type="html"><![CDATA[PowerShell ProgressBar -- Part 3]]></title>
 <link rel="alternate" type="text/html" href="http://tiberriver256.github.io/powershell/PowerShellProgress-Pt3/" />
  <id>http://tiberriver256.github.io/powershell/PowerShellProgress-Pt3</id>
  <updated>{}T00:00:00-00:00</updated>
  <published>2015-12-14T00:00:00+00:00</published>
  
  <author>
    <name>Micah Rairdon</name>
    <uri>http://tiberriver256.github.io</uri>
    <email>Jun(Real Email: Micah.Rairdon [GMail])k@JunkMail.com</email>
  </author>
  <content type="html">
    &lt;h2 id=&quot;the-series&quot;&gt;The Series&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-P1/&quot;&gt;PowerShell ProgressBar – Part 1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt2/&quot;&gt;PowerShell ProgressBar – Part 2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt4/&quot;&gt;PowerShell ProgressBar – Part 4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-TheModule/&quot;&gt;The Module Released&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Okay, so we have a progress bar that shows percentage. Big whoop, who cares!? I need all the details! I need to show all the things! Well…. the time has come. Behold, details being added…&lt;/p&gt;

&lt;h2 id=&quot;easy-peasy&quot;&gt;Easy Peasy&lt;/h2&gt;

&lt;p&gt;At this point, in order to add in a bit of details we need to do the following tasks:
 1. Add a textblock to our XAML underneath the plain old progress bar
 2. Add an update call to the update block triggered by the timer in our previous posting.
 3. Add if statements to our &lt;strong&gt;Write-ProgressBar&lt;/strong&gt; cmdlet&lt;/p&gt;

&lt;p&gt;The typical &lt;strong&gt;Write-Progress&lt;/strong&gt; cmdlet takes the following three parameters and mushes them together, in order, underneath your progressbar:
 1. Status
 2. Seconds Remaining
 3. CurrentOperation&lt;/p&gt;

&lt;p&gt;On the cmdlet side it helps to have these split out to make calling the cmdlet easier. On the UI side though it just complicates things unnecessarily, so I simply added a single variable to my &lt;strong&gt;New-ProgressBar&lt;/strong&gt; cmdlet called &lt;em&gt;AdditionalInfo&lt;/em&gt; on my synchash:&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;ps&quot;&gt;
$syncHash.AdditionalInfo = &#39;&#39;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;We add the following textblock code to our XAML to create the label underneath the progress bar:&lt;/p&gt;

&lt;pre&gt;
&amp;lt;code class=&quot;xml&quot;
&lt;textblock name=&quot;AdditionalInfoTextBlock&quot; text=&quot;&quot; horizontalalignment=&quot;Center&quot; verticalalignment=&quot;Center&quot; /&gt;

&lt;/pre&gt;

&lt;p&gt;Making all three variables squished into one makes the addition to my update block a single line of code:&lt;/p&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;
$SyncHash.AdditionalInfoTextBlock.Text = $SyncHash.AdditionalInfo
&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;Now I add in the addtional parameters to the param section of my &lt;strong&gt;Write-ProgressBar&lt;/strong&gt; cmdlet as follows:&lt;/p&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;
        [String]$Status = $Null,
        [int]$SecondsRemaining = $Null,
        [String]$CurrentOperation = $Null
&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;My if statements on whether or not to add these parameters and combining them with spacing into the AdditionalInfo paramater looks like this:&lt;/p&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;
if($SecondsRemaining)
   {

       [String]$SecondsRemaining = &quot;$SecondsRemaining Seconds Remaining&quot;

   }
   else
   {

       [String]$SecondsRemaining = $Null

   }

   Write-Verbose -Message &quot;Setting AdditionalInfo to $Status       $SecondsRemaining$(if($SecondsRemaining){ &quot; seconds remaining...&quot; }else {&#39;&#39;})       $CurrentOperation&quot;
   $ProgressBar.AdditionalInfo = &quot;$Status       $SecondsRemaining       $CurrentOperation&quot;

&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;Now if I run the demo provided at the end of this article we get the following:&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;http://tiberriver256.github.io/images/PowerProgress/PowerShell ProgressBar.gif&quot; /&gt;
	&lt;figcaption&gt;Give me alllll the deets!&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Nice eh!?&lt;/p&gt;

&lt;h1 id=&quot;full-code&quot;&gt;Full Code&lt;/h1&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;
Function New-ProgressBar {
 
    [void][System.Reflection.Assembly]::LoadWithPartialName(&#39;presentationframework&#39;) 
    $syncHash = [hashtable]::Synchronized(@{})
    $newRunspace =[runspacefactory]::CreateRunspace()
    $syncHash.Runspace = $newRunspace
    $syncHash.AdditionalInfo = &#39;&#39;
    $newRunspace.ApartmentState = &quot;STA&quot; 
    $newRunspace.ThreadOptions = &quot;ReuseThread&quot;           
    $data = $newRunspace.Open() | Out-Null
    $newRunspace.SessionStateProxy.SetVariable(&quot;syncHash&quot;,$syncHash)           
    $PowerShellCommand = [PowerShell]::Create().AddScript({    
        [string]$xaml = @&quot; 
        &lt;window xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; name=&quot;Window&quot; title=&quot;Progress...&quot; windowstartuplocation=&quot;CenterScreen&quot; width=&quot;560&quot; height=&quot;130&quot; sizetocontent=&quot;Height&quot; showintaskbar=&quot;True&quot;&gt; 
            &lt;stackpanel margin=&quot;20&quot;&gt;
               &lt;progressbar width=&quot;560&quot; name=&quot;ProgressBar&quot; /&gt;
               &lt;textblock text=&quot;{Binding ElementName=ProgressBar, Path=Value, StringFormat={}{0:0}%}&quot; horizontalalignment=&quot;Center&quot; verticalalignment=&quot;Center&quot; /&gt;
               &lt;textblock name=&quot;AdditionalInfoTextBlock&quot; text=&quot;&quot; horizontalalignment=&quot;Center&quot; verticalalignment=&quot;Center&quot; /&gt;
            &lt;/stackpanel&gt; 
        &lt;/window&gt; 
&quot;@ 
   
        $syncHash.Window=[Windows.Markup.XamlReader]::parse( $xaml ) 
        #===========================================================================
        # Store Form Objects In PowerShell
        #===========================================================================
        ([xml]$xaml).SelectNodes(&quot;//*[@Name]&quot;) | %{ $SyncHash.&quot;$($_.Name)&quot; = $SyncHash.Window.FindName($_.Name)}

        $updateBlock = {            
            
            $SyncHash.Window.Title = $SyncHash.Activity
            $SyncHash.ProgressBar.Value = $SyncHash.PercentComplete
            $SyncHash.AdditionalInfoTextBlock.Text = $SyncHash.AdditionalInfo
            #$SyncHash.Window.MinWidth = $SyncHash.Window.ActualWidth
                       
        }

        ############### New Blog ##############
        $syncHash.Window.Add_SourceInitialized( {            
            ## Before the window&#39;s even displayed ...            
            ## We&#39;ll create a timer            
            $timer = new-object System.Windows.Threading.DispatcherTimer            
            ## Which will fire 4 times every second            
            $timer.Interval = [TimeSpan]&quot;0:0:0.01&quot;            
            ## And will invoke the $updateBlock            
            $timer.Add_Tick( $updateBlock )            
            ## Now start the timer running            
            $timer.Start()            
            if( $timer.IsEnabled ) {            
               Write-Host &quot;Clock is running. Don&#39;t forget: RIGHT-CLICK to close it.&quot;            
            } else {            
               $clock.Close()            
               Write-Error &quot;Timer didn&#39;t start&quot;            
            }            
        } )

        $syncHash.Window.ShowDialog() | Out-Null 
        $syncHash.Error = $Error 

    }) 
    $PowerShellCommand.Runspace = $newRunspace 
    $data = $PowerShellCommand.BeginInvoke() 
   
    
    Register-ObjectEvent -InputObject $SyncHash.Runspace `
            -EventName &#39;AvailabilityChanged&#39; `
            -Action { 
                
                    if($Sender.RunspaceAvailability -eq &quot;Available&quot;)
                    {
                        $Sender.Closeasync()
                        $Sender.Dispose()
                    } 
                
                } | Out-Null

    return $syncHash

}

function Write-ProgressBar
{

    Param (
        [Parameter(Mandatory=$true)]
        $ProgressBar,
        [Parameter(Mandatory=$true)]
        [String]$Activity,
        [int]$PercentComplete,
        [String]$Status = $Null,
        [int]$SecondsRemaining = $Null,
        [String]$CurrentOperation = $Null
    ) 
   
   Write-Verbose -Message &quot;Setting activity to $Activity&quot;
   $ProgressBar.Activity = $Activity

   if($PercentComplete)
   {
       
       Write-Verbose -Message &quot;Setting PercentComplete to $PercentComplete&quot;
       $ProgressBar.PercentComplete = $PercentComplete

   }
   
   if($SecondsRemaining)
   {

       [String]$SecondsRemaining = &quot;$SecondsRemaining Seconds Remaining&quot;

   }
   else
   {

       [String]$SecondsRemaining = $Null

   }

   Write-Verbose -Message &quot;Setting AdditionalInfo to $Status       $SecondsRemaining$(if($SecondsRemaining){ &quot; seconds remaining...&quot; }else {&#39;&#39;})       $CurrentOperation&quot;
   $ProgressBar.AdditionalInfo = &quot;$Status       $SecondsRemaining       $CurrentOperation&quot;

}

function Close-ProgressBar
{

    Param (
        [Parameter(Mandatory=$true)]
        [System.Object[]]$ProgressBar
    )

    $ProgressBar.Window.Dispatcher.Invoke([action]{ 
      
      $ProgressBar.Window.close()

    }, &quot;Normal&quot;)
 
}
&lt;/code&gt; &lt;/pre&gt;

&lt;h1 id=&quot;demo&quot;&gt;Demo&lt;/h1&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;

$ProgressBar = New-ProgressBar

Measure-Command -Expression {
    $Files = dir $env:USERPROFILE -Recurse
    $i = 0
    $Files | foreach {
    
                        $i++
                        Start-Sleep -Milliseconds 10
    
                        Write-ProgressBar `
                                -ProgressBar $ProgressBar `
                                -Activity &quot;Viewing Files&quot; `
                                -PercentComplete (($i/$Files.count) * 100) `
                                -CurrentOperation $_.FullName `
                                -Status $_.Name `
                                -SecondsRemaining (100 - $_.count)
                     }
}

&lt;/code&gt; &lt;/pre&gt;

    &lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt3/&quot;&gt;PowerShell ProgressBar -- Part 3&lt;/a&gt; was originally published by Micah Rairdon at &lt;a href=&quot;http://tiberriver256.github.io&quot;&gt;Tiberriver256&lt;/a&gt; on December 14, 2015.&lt;/p&gt;
  </content>
</entry>


<entry>
  <title type="html"><![CDATA[PowerShell ProgressBar -- Part 2]]></title>
 <link rel="alternate" type="text/html" href="http://tiberriver256.github.io/powershell/PowerShellProgress-Pt2/" />
  <id>http://tiberriver256.github.io/powershell/PowerShellProgress-Pt2</id>
  <updated>{}T00:00:00-00:00</updated>
  <published>2015-12-09T00:00:00+00:00</published>
  
  <author>
    <name>Micah Rairdon</name>
    <uri>http://tiberriver256.github.io</uri>
    <email>Jun(Real Email: Micah.Rairdon [GMail])k@JunkMail.com</email>
  </author>
  <content type="html">
    &lt;h2 id=&quot;the-series&quot;&gt;The Series&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt1/&quot;&gt;PowerShell ProgressBar – Part 1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt3/&quot;&gt;PowerShell ProgressBar – Part 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt4/&quot;&gt;PowerShell ProgressBar – Part 4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-TheModule/&quot;&gt;The Module Released&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Welcome back for more fun with PowerShell and XAML ProgressBars! Today we are going to tackle performance tuning all on it’s own.&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;
&lt;p&gt;If you attempted to run the demo at the end of &lt;a href=&quot;tiberriver256.github.io/powershell/PowerShellProgress-Pt1/&quot; title=&quot;PowerShell ProgressBar -- Part 1&quot;&gt;PowerShell ProgressBar – Part 1&lt;/a&gt;, and you were sneaky enough to remove my &lt;strong&gt;Start-Sleep&lt;/strong&gt; cmdlet you may have noticed that the performance is AWFUL!&lt;/p&gt;

&lt;p&gt;Here are the stats just running the following progress bar demo code (&lt;strong&gt;Start-Sleep&lt;/strong&gt; removed):&lt;/p&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;
1..100 | foreach {Write-ProgressBar -ProgressBar $ProgressBar -Activity &quot;Counting $_ out of 100&quot; -PercentComplete $_ }
&lt;/code&gt; &lt;/pre&gt;

&lt;figure&gt;
	&lt;img src=&quot;http://tiberriver256.github.io/images/PowerProgress/SlowPerformance.JPG&quot; /&gt;
	&lt;figcaption&gt;50 seconds to count to 100!&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;50 seconds just to count to 100 is a lot of overhead to a script just to add a progress bar. In most cases end users want speed over shininess so we are going to need to fix this.&lt;/p&gt;

&lt;h2 id=&quot;the-solution&quot;&gt;The Solution&lt;/h2&gt;
&lt;p&gt;Doing a quick Google search turned up the fact that other people had experienced the same issue when using dispatcher.invoke&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; it turns out this is because dispatcher.invoke is thread blocking (i.e. your script has to wait for the invoke function, which has quite a bit of overhead, to complete before it will continue).&lt;/p&gt;

&lt;p&gt;Turns out the there are a few other non-threadblocking methods for updating your GUI. I chose to use something called the dispatchertimer because of this dandy article&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; and a sweet simple demo from Richard Siddaway&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;What the dispatchertimer allows us to do is tell our GUI to run some code on a set interval. So, I want my GUI to update every ten milliseconds to reflect the properties on my &lt;strong&gt;$Synchash&lt;/strong&gt; and this should dramatically increase our performance.&lt;/p&gt;

&lt;p&gt;So, to walk it through. We added a property for the activity and a property to for the percentcomplete to our &lt;strong&gt;$Synchash&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;
$syncHash.Activity = &#39;&#39;
$syncHash.PercentComplete = 0
&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;We then created a scriptblock to that we wanted to run at the set interval which will update the GUI.&lt;/p&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;
$updateBlock = {            
            
    $SyncHash.Window.Title = $SyncHash.Activity
    $SyncHash.ProgressBar.Value = $SyncHash.PercentComplete
                       
 }
&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;Then we will create the dispatchtimer which will call the code and set the interval to be 10 milliseconds.&lt;/p&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;

$syncHash.Window.Add_SourceInitialized( {            
            ## Before the window&#39;s even displayed ...            
            ## We&#39;ll create a timer            
            $timer = new-object System.Windows.Threading.DispatcherTimer            
            ## Which will fire 4 times every second            
            $timer.Interval = [TimeSpan]&quot;0:0:0.01&quot;            
            ## And will invoke the $updateBlock            
            $timer.Add_Tick( $updateBlock )            
            ## Now start the timer running            
            $timer.Start()            
            if( $timer.IsEnabled ) {            
               Write-Host &quot;Clock is running. Don&#39;t forget: RIGHT-CLICK to close it.&quot;            
            } else {            
               $clock.Close()            
               Write-Error &quot;Timer didn&#39;t start&quot;            
            }            
  } )

&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;This makes my &lt;strong&gt;Write-ProgressBar&lt;/strong&gt; cmdlet as simple as changing a property on the variable.&lt;/p&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;

function Write-ProgressBar
{

    Param (
        [Parameter(Mandatory=$true)]
        $ProgressBar,
        [Parameter(Mandatory=$true)]
        [String]$Activity,
        [int]$PercentComplete
    ) 
   
   $ProgressBar.Activity = $Activity

   if($PercentComplete)
   {
      
       $ProgressBar.PercentComplete = $PercentComplete

   }

}

&lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;The end results in performance are… Drumroll please!!!&lt;/p&gt;
&lt;figure&gt;
	&lt;img src=&quot;http://tiberriver256.github.io/images/PowerProgress/RockinPerformance.JPG&quot; /&gt;
	&lt;figcaption&gt;68 milliseconds to complete the same code!&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;full-code&quot;&gt;Full Code&lt;/h2&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;

Function New-ProgressBar {
 
    [void][System.Reflection.Assembly]::LoadWithPartialName(&#39;presentationframework&#39;) 
    $syncHash = [hashtable]::Synchronized(@{})
    $newRunspace =[runspacefactory]::CreateRunspace()
    $syncHash.Runspace = $newRunspace
    $syncHash.Activity = &#39;&#39;
    $syncHash.PercentComplete = 0
    $newRunspace.ApartmentState = &quot;STA&quot; 
    $newRunspace.ThreadOptions = &quot;ReuseThread&quot;           
    $data = $newRunspace.Open() | Out-Null
    $newRunspace.SessionStateProxy.SetVariable(&quot;syncHash&quot;,$syncHash)           
    $PowerShellCommand = [PowerShell]::Create().AddScript({    
        [xml]$xaml = @&quot; 
        &lt;window xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; name=&quot;Window&quot; title=&quot;Progress...&quot; windowstartuplocation=&quot;CenterScreen&quot; width=&quot;300&quot; height=&quot;100&quot; showintaskbar=&quot;True&quot;&gt; 
            &lt;stackpanel margin=&quot;20&quot;&gt;
               &lt;progressbar name=&quot;ProgressBar&quot; /&gt;
               &lt;textblock text=&quot;{Binding ElementName=ProgressBar, Path=Value, StringFormat={}{0:0}%}&quot; horizontalalignment=&quot;Center&quot; verticalalignment=&quot;Center&quot; /&gt;
            &lt;/stackpanel&gt; 
        &lt;/window&gt; 
&quot;@ 
  
        $reader=(New-Object System.Xml.XmlNodeReader $xaml) 
        $syncHash.Window=[Windows.Markup.XamlReader]::Load( $reader ) 
        #===========================================================================
        # Store Form Objects In PowerShell
        #===========================================================================
        $xaml.SelectNodes(&quot;//*[@Name]&quot;) | %{ $SyncHash.&quot;$($_.Name)&quot; = $SyncHash.Window.FindName($_.Name)}

        $updateBlock = {            
            
            $SyncHash.Window.Title = $SyncHash.Activity
            $SyncHash.ProgressBar.Value = $SyncHash.PercentComplete
                       
        }

        ############### New Blog ##############
        $syncHash.Window.Add_SourceInitialized( {            
            ## Before the window&#39;s even displayed ...            
            ## We&#39;ll create a timer            
            $timer = new-object System.Windows.Threading.DispatcherTimer            
            ## Which will fire 4 times every second            
            $timer.Interval = [TimeSpan]&quot;0:0:0.01&quot;            
            ## And will invoke the $updateBlock            
            $timer.Add_Tick( $updateBlock )            
            ## Now start the timer running            
            $timer.Start()            
            if( $timer.IsEnabled ) {            
               Write-Host &quot;Clock is running. Don&#39;t forget: RIGHT-CLICK to close it.&quot;            
            } else {            
               $clock.Close()            
               Write-Error &quot;Timer didn&#39;t start&quot;            
            }            
        } )

        $syncHash.Window.ShowDialog() | Out-Null 
        $syncHash.Error = $Error 

    }) 
    $PowerShellCommand.Runspace = $newRunspace 
    $data = $PowerShellCommand.BeginInvoke() 
   
    
    Register-ObjectEvent -InputObject $SyncHash.Runspace `
            -EventName &#39;AvailabilityChanged&#39; `
            -Action { 
                
                    if($Sender.RunspaceAvailability -eq &quot;Available&quot;)
                    {
                        $Sender.Closeasync()
                        $Sender.Dispose()
                    } 
                
                } | Out-Null

    return $syncHash

}
 

function Write-ProgressBar
{

    Param (
        [Parameter(Mandatory=$true)]
        $ProgressBar,
        [Parameter(Mandatory=$true)]
        [String]$Activity,
        [int]$PercentComplete
    ) 
   
   $ProgressBar.Activity = $Activity

   if($PercentComplete)
   {
      
       $ProgressBar.PercentComplete = $PercentComplete

   }

}

function Close-ProgressBar
{

    Param (
        [Parameter(Mandatory=$true)]
        [System.Object[]]$ProgressBar
    )

    $ProgressBar.Window.Dispatcher.Invoke([action]{ 
      
      $ProgressBar.Window.close()

    }, &quot;Normal&quot;)
 
}

&lt;/code&gt; &lt;/pre&gt;

&lt;h2 id=&quot;demo&quot;&gt;Demo&lt;/h2&gt;

&lt;pre&gt; &lt;code class=&quot;ps&quot;&gt;
 #Put a Start-Sleep back in if you actually want to see the progress bar up.
$ProgressBar = New-ProgressBar
Measure-Command -Expression {
    1..100 | foreach {Write-ProgressBar -ProgressBar $ProgressBar -Activity &quot;Counting $_ out of 100&quot; -PercentComplete $_}
}
Close-ProgressBar $ProgressBar

&lt;/code&gt; &lt;/pre&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://social.msdn.microsoft.com/Forums/vstudio/en-US/080f7b59-38ec-4a45-944d-e538b08f525b/why-is-the-dispatcher-so-slow?forum=wpf&quot;&gt;https://social.msdn.microsoft.com/Forums/vstudio/en-US/080f7b59-38ec-4a45-944d-e538b08f525b/why-is-the-dispatcher-so-slow?forum=wpf&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://jkshay.com/implementing-the-net-dispatchertimer/&quot;&gt;http://jkshay.com/implementing-the-net-dispatchertimer/&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://richardspowershellblog.wordpress.com/2011/07/07/a-powershell-clock/&quot;&gt;https://richardspowershellblog.wordpress.com/2011/07/07/a-powershell-clock/&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;

    &lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt2/&quot;&gt;PowerShell ProgressBar -- Part 2&lt;/a&gt; was originally published by Micah Rairdon at &lt;a href=&quot;http://tiberriver256.github.io&quot;&gt;Tiberriver256&lt;/a&gt; on December 09, 2015.&lt;/p&gt;
  </content>
</entry>


<entry>
  <title type="html"><![CDATA[PowerShell ProgressBar -- Part 1]]></title>
 <link rel="alternate" type="text/html" href="http://tiberriver256.github.io/powershell/PowerShellProgress-Pt1/" />
  <id>http://tiberriver256.github.io/powershell/PowerShellProgress-Pt1</id>
  <updated>{}T00:00:00-00:00</updated>
  <published>2015-12-06T00:00:00+00:00</published>
  
  <author>
    <name>Micah Rairdon</name>
    <uri>http://tiberriver256.github.io</uri>
    <email>Jun(Real Email: Micah.Rairdon [GMail])k@JunkMail.com</email>
  </author>
  <content type="html">
    &lt;h2 id=&quot;the-series&quot;&gt;The Series&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt2/&quot;&gt;PowerShell ProgressBar – Part 2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt3/&quot;&gt;PowerShell ProgressBar – Part 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt4/&quot;&gt;PowerShell ProgressBar – Part 4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-TheModule/&quot;&gt;The Module Released&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Making PowerShell progress bars has always been a handy feature of PowerShell. End users and admins alike love to see that bar progressing just so they know the script is going somewhere. &lt;strong&gt;Write-Progress&lt;/strong&gt; is a great tool built into Windows but sometimes you want to hide that black scary screen and surface a beautiful shiny bar of progress that will make your end user oooo and ahhhhh and your PowerShell prowess.&lt;/p&gt;

&lt;p&gt;What I am going to do over the next few posts is create a decent PowerShell progress bar that will have the following feautures:
1. Update asynchronous from the script (credit goes to Boe Prox&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; and Rhys W Edwards &lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;)
2. Awesome styles (Material Design and MahApps)&lt;/p&gt;

&lt;h2 id=&quot;the-basics&quot;&gt;The Basics&lt;/h2&gt;

&lt;p&gt;This module will be made up of three cmdlets:
1. &lt;strong&gt;New-ProgressBar&lt;/strong&gt; - Used to create a ProgressBar variable attached to progressbar in separaterunspace. Select styling.
2. &lt;strong&gt;Write-ProgressBar&lt;/strong&gt; - Used to send progress events to the ProgressBar. &lt;em&gt;Attempts to modify the variable directly will fail due to runspace security&lt;/em&gt;
3. &lt;strong&gt;Close-ProgressBar&lt;/strong&gt; - Used to close out the ProgressBar safely and cleanly to prevent memory issues.&lt;/p&gt;

&lt;h3 id=&quot;new-progressbar&quot;&gt;New-ProgressBar&lt;/h3&gt;
&lt;p&gt;Let’s start with implementing the &lt;strong&gt;New-ProgressBar&lt;/strong&gt; cmdlet and see what all that entails. I strongly recommend reading the referenced article from Boe Prox on managing runspaces before continuing (It’s short).&lt;/p&gt;

&lt;p&gt;In order to have the progress bar run without interrupting the current process we need to create it in a separate runspace.&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;ps&quot;&gt;
    $SyncHash = [hashtable]::Synchronized(@{})
    $newRunspace =[runspacefactory]::CreateRunspace()
    $SyncHash.Runspace = $newRunspace
    $newRunspace.ApartmentState = &quot;STA&quot; 
    $newRunspace.ThreadOptions = &quot;ReuseThread&quot;           
    $newRunspace.Open() 
    $newRunspace.SessionStateProxy.SetVariable(&quot;syncHash&quot;,$syncHash)
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;The &lt;strong&gt;$SyncHash&lt;/strong&gt; variable is going to be used to manage the progress bar from the current thread as we’ll see later in the &lt;strong&gt;Write-Progress&lt;/strong&gt; cmdlet.&lt;/p&gt;

&lt;p&gt;The next step is to create the command that will run in this alternate runspace which creates a very basic xaml progress bar and adds the elements of the progressbar to the &lt;strong&gt;$SyncHash&lt;/strong&gt; for later modificiation.&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;ps&quot;&gt;
    $PowerShellCommand = [PowerShell]::Create().AddScript({    
        [xml]$xaml = @&quot; 
        &lt;window xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; name=&quot;Window&quot; title=&quot;Progress...&quot; windowstartuplocation=&quot;CenterScreen&quot; width=&quot;300&quot; height=&quot;100&quot; showintaskbar=&quot;True&quot;&gt; 
            &lt;stackpanel margin=&quot;20&quot;&gt;
               &lt;progressbar name=&quot;ProgressBar&quot; value=&quot;40&quot; /&gt;
               &lt;textblock text=&quot;{Binding ElementName=ProgressBar, Path=Value, StringFormat={}{0:0}%}&quot; horizontalalignment=&quot;Center&quot; verticalalignment=&quot;Center&quot; /&gt;
            &lt;/stackpanel&gt; 
        &lt;/window&gt; 
&quot;@ 
  
        $reader=(New-Object System.Xml.XmlNodeReader $xaml) 
        $syncHash.Window=[Windows.Markup.XamlReader]::Load( $reader ) 
        #===========================================================================
        # Store Form Objects In PowerShell
        #===========================================================================
        $xaml.SelectNodes(&quot;//*[@Name]&quot;) | %{ $SyncHash.&quot;$($_.Name)&quot; = $SyncHash.Window.FindName($_.Name)}


        $syncHash.Window.ShowDialog() | Out-Null 
        $syncHash.Error = $Error 

    }) 
    $PowerShellCommand.Runspace = $newRunspace 
    $data = $PowerShellCommand.BeginInvoke()
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;At this point we should have a progress bar running asynchronously in a separate runspace. Now all we have to do is wrap this in a function and return the &lt;strong&gt;$SyncHash&lt;/strong&gt; as the result for future modification.&lt;/p&gt;

&lt;p&gt;I did, however, just in case someone sent it to the pipeline without storing it in a variable a sort of safeguard to close the runspace if it became orphaned or the progress bar was closed.&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;ps&quot;&gt;
Register-ObjectEvent -InputObject $SyncHash.Runspace `
            -EventName &#39;AvailabilityChanged&#39; `
            -Action { 
                
                    if($Sender.RunspaceAvailability -eq &quot;Available&quot;)
                    {
                        $Sender.Closeasync()
                        $Sender.Dispose()
                    } 
                
                }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;This will basically listen for when the availability (typically &lt;strong&gt;busy&lt;/strong&gt; while the progress bar is running) to change and if it is &lt;strong&gt;Available&lt;/strong&gt; go ahead and close out the runspace and dispose it.&lt;/p&gt;

&lt;p&gt;The full function appears here:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;ps&quot;&gt;
Function New-ProgressBar {
 
    [void][System.Reflection.Assembly]::LoadWithPartialName(&#39;presentationframework&#39;) 
    $syncHash = [hashtable]::Synchronized(@{})
    $newRunspace =[runspacefactory]::CreateRunspace()
    $syncHash.Runspace = $newRunspace
    $newRunspace.ApartmentState = &quot;STA&quot; 
    $newRunspace.ThreadOptions = &quot;ReuseThread&quot;           
    $newRunspace.Open() 
    $newRunspace.SessionStateProxy.SetVariable(&quot;syncHash&quot;,$syncHash)           
    $PowerShellCommand = [PowerShell]::Create().AddScript({    
        [xml]$xaml = @&quot; 
        &lt;window xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; name=&quot;Window&quot; title=&quot;Progress...&quot; windowstartuplocation=&quot;CenterScreen&quot; width=&quot;300&quot; height=&quot;100&quot; showintaskbar=&quot;True&quot;&gt; 
            &lt;stackpanel margin=&quot;20&quot;&gt;
               &lt;progressbar name=&quot;ProgressBar&quot; value=&quot;40&quot; /&gt;
               &lt;textblock text=&quot;{Binding ElementName=ProgressBar, Path=Value, StringFormat={}{0:0}%}&quot; horizontalalignment=&quot;Center&quot; verticalalignment=&quot;Center&quot; /&gt;
            &lt;/stackpanel&gt; 
        &lt;/window&gt; 
&quot;@ 
  
        $reader=(New-Object System.Xml.XmlNodeReader $xaml) 
        $syncHash.Window=[Windows.Markup.XamlReader]::Load( $reader ) 
        #===========================================================================
        # Store Form Objects In PowerShell
        #===========================================================================
        $xaml.SelectNodes(&quot;//*[@Name]&quot;) | %{ $SyncHash.&quot;$($_.Name)&quot; = $SyncHash.Window.FindName($_.Name)}


        $syncHash.Window.ShowDialog() | Out-Null 
        $syncHash.Error = $Error 

    }) 
    $PowerShellCommand.Runspace = $newRunspace 
    $data = $PowerShellCommand.BeginInvoke() 
   
    
    Register-ObjectEvent -InputObject $SyncHash.Runspace `
            -EventName &#39;AvailabilityChanged&#39; `
            -Action { 
                
                    if($Sender.RunspaceAvailability -eq &quot;Available&quot;)
                    {
                        $Sender.Closeasync()
                        $Sender.Dispose()
                    } 
                
                } 

    return $SyncHash

}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;write-progressbar&quot;&gt;Write-ProgressBar&lt;/h3&gt;
&lt;p&gt;Now to build our starting &lt;strong&gt;Write-ProgressBar&lt;/strong&gt; function. To start out we aren’t going to want to mess with re-creating every functionality of &lt;strong&gt;Write-Progress&lt;/strong&gt;, so we are just going to add the ability to pass in an updated &lt;strong&gt;Activity&lt;/strong&gt; which will update the title of the progress bar window and &lt;strong&gt;PercentComplete&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;If you didn’t read Boe’s article you may have already attempted to update the progressbar using the &lt;strong&gt;$SyncHash&lt;/strong&gt; Variable. This will sadly not work. Something about security or something. So what we are going to do is modify the properties in the second runspace by using the dispatcher which is exposed in our &lt;strong&gt;$SyncHash&lt;/strong&gt; variable.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;ps&quot;&gt;
function Write-ProgressBar
{

    Param (
        [Parameter(Mandatory=$true)]
        [System.Object[]]$ProgressBar,
        [Parameter(Mandatory=$true)]
        [String]$Activity,
        [int]$PercentComplete
    ) 
   
   # This updates the control based on the parameters passed to the function 
   $ProgressBar.Window.Dispatcher.Invoke([action]{ 
      
      $ProgressBar.Window.Title = $Activity

   }, &quot;Normal&quot;)

   if($PercentComplete)
   {

       $ProgressBar.Window.Dispatcher.Invoke([action]{ 
      
          $ProgressBar.ProgressBar.Value = $PercentComplete

       }, &quot;Normal&quot;)

   }

}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;close-progressbar&quot;&gt;Close-ProgressBar&lt;/h3&gt;

&lt;p&gt;The &lt;strong&gt;Close-ProgressBar&lt;/strong&gt; function is going to be very similar.&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;ps&quot;&gt;
function Close-ProgressBar
{

    Param (
        [Parameter(Mandatory=$true)]
        [System.Object[]]$ProgressBar
    )

    $ProgressBar.Window.Dispatcher.Invoke([action]{ 
      
      $ProgressBar.Window.Close()

    }, &quot;Normal&quot;)
 
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Hope you enjoy! The next posting we will get into replicating the exact functionality of the write-progress function as well as dealing with some of the performance issues you will see when running the below demo. The third we will get into styling our progress bars.&lt;/p&gt;

&lt;p&gt;Below is the full code so far and a demo:&lt;/p&gt;

&lt;h2 id=&quot;full-code&quot;&gt;Full Code&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;ps&quot;&gt;

# Function to facilitate updates to controls within the window 
Function New-ProgressBar {
 
    [void][System.Reflection.Assembly]::LoadWithPartialName(&#39;presentationframework&#39;) 
    $syncHash = [hashtable]::Synchronized(@{})
    $newRunspace =[runspacefactory]::CreateRunspace()
    $syncHash.Runspace = $newRunspace
    $newRunspace.ApartmentState = &quot;STA&quot; 
    $newRunspace.ThreadOptions = &quot;ReuseThread&quot;           
    $newRunspace.Open() 
    $newRunspace.SessionStateProxy.SetVariable(&quot;syncHash&quot;,$syncHash)           
    $PowerShellCommand = [PowerShell]::Create().AddScript({    
        [xml]$xaml = @&quot; 
        &lt;window xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; name=&quot;Window&quot; title=&quot;Progress...&quot; windowstartuplocation=&quot;CenterScreen&quot; width=&quot;300&quot; height=&quot;100&quot; showintaskbar=&quot;True&quot;&gt; 
            &lt;stackpanel margin=&quot;20&quot;&gt;
               &lt;progressbar name=&quot;ProgressBar&quot; /&gt;
               &lt;textblock text=&quot;{Binding ElementName=ProgressBar, Path=Value, StringFormat={}{0:0}%}&quot; horizontalalignment=&quot;Center&quot; verticalalignment=&quot;Center&quot; /&gt;
            &lt;/stackpanel&gt; 
        &lt;/window&gt; 
&quot;@ 
  
        $reader=(New-Object System.Xml.XmlNodeReader $xaml) 
        $syncHash.Window=[Windows.Markup.XamlReader]::Load( $reader ) 
        #===========================================================================
        # Store Form Objects In PowerShell
        #===========================================================================
        $xaml.SelectNodes(&quot;//*[@Name]&quot;) | %{ $SyncHash.&quot;$($_.Name)&quot; = $SyncHash.Window.FindName($_.Name)}


        $syncHash.Window.ShowDialog() | Out-Null 
        $syncHash.Error = $Error 

    }) 
    $PowerShellCommand.Runspace = $newRunspace 
    $data = $PowerShellCommand.BeginInvoke() 
   
    
    Register-ObjectEvent -InputObject $SyncHash.Runspace `
            -EventName &#39;AvailabilityChanged&#39; `
            -Action { 
                
                    if($Sender.RunspaceAvailability -eq &quot;Available&quot;)
                    {
                        $Sender.Closeasync()
                        $Sender.Dispose()
                    } 
                
                } 

    return [System.Collections.Hashtable]$SyncHash

}
 

function Write-ProgressBar
{

    Param (
        [Parameter(Mandatory=$true)]
        [System.Object[]]$ProgressBar,
        [Parameter(Mandatory=$true)]
        [String]$Activity,
        [String]$Status,
        [int]$Id,
        [int]$PercentComplete,
        [int]$SecondsRemaining,
        [String]$CurrentOperation,
        [int]$ParentId,
        [Switch]$Completed,
        [int]$SourceID
    ) 
   
   # This updates the control based on the parameters passed to the function 
   $ProgressBar.Window.Dispatcher.Invoke([action]{ 
      
      $ProgressBar.Window.Title = $Activity

   }, &quot;Normal&quot;)

   if($PercentComplete)
   {

       $ProgressBar.Window.Dispatcher.Invoke([action]{ 
      
          $ProgressBar.ProgressBar.Value = $PercentComplete

       }, &quot;Normal&quot;)

   }

}


function Close-ProgressBar
{

    Param (
        [Parameter(Mandatory=$true)]
        [System.Object[]]$ProgressBar
    )

    $ProgressBar.Window.Dispatcher.Invoke([action]{ 
      
      $ProgressBar.Window.Close()

    }, &quot;Normal&quot;)
 
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;demo&quot;&gt;Demo&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Run this after creating the above functions&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;ps&quot;&gt;
$ProgressBar = New-ProgressBar

1..100 | foreach {Write-ProgressBar -ProgressBar $ProgressBar -Activity &quot;Counting $_ out of 100&quot; -PercentComplete $_; Start-Sleep -Milliseconds 250}

Close-ProgressBar $ProgressBar
&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://learn-powershell.net/2012/10/14/powershell-and-wpf-writing-data-to-a-ui-from-a-different-runspace/&quot;&gt;http://learn-powershell.net/2012/10/14/powershell-and-wpf-writing-data-to-a-ui-from-a-different-runspace/&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://gallery.technet.microsoft.com/scriptcenter/New-ProgressBar-8468da5c&quot;&gt;https://gallery.technet.microsoft.com/scriptcenter/New-ProgressBar-8468da5c&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;

    &lt;p&gt;&lt;a href=&quot;http://tiberriver256.github.io/powershell/PowerShellProgress-Pt1/&quot;&gt;PowerShell ProgressBar -- Part 1&lt;/a&gt; was originally published by Micah Rairdon at &lt;a href=&quot;http://tiberriver256.github.io&quot;&gt;Tiberriver256&lt;/a&gt; on December 06, 2015.&lt;/p&gt;
  </content>
</entry>

</feed>
